; PREDEF, do not touch

def {fun} (
  \{args & body} 
  "Helper function for \\. 'fun {add x y} {+ x y}' defines a function assigned to add. You can add a comment as well: 'fun {add x y} \"My binary add.\" {+ x y}' which will be shown when you enter 'help add'." 
  {
    def (head args) (
      if (== 1 (len body)) {
        \ (tail args) (eval body)
      } {
        \ (tail args) (eval (head body)) (eval (head (tail body)))
      }
    )
 }
)

fun {unpack f xs} "Unpacks an expression and applies given function to it. 'unpack + {1 2 3}'." {eval (cons f xs)}

fun {pack f & xs} "Packs an expression and applies given function to the resulting Q expression. 'pack eval + 1 2 3'" {f xs}

fun {reverse l} "Reverses a given Q expression. 'eval (reverse {2 1 +})'" {
  if (< 2 (len l)) 
    {join (reverse (tail l)) (head l)}
    {if (== 2 (len l)) {join (at l 1) (at l 0)} {l} }
}

fun {repeat n expr} "Repeats an expression. 'unpack + (repeat 200 1)'" {if (== 0 n) {{}} {cons expr (repeat (- n 1) expr)}}

fun {do & actions} "Executes several actions in a row. Returns the value of the last action." {
  if (!= {} actions) { eval (last actions) }
}

fun {let body} "Opens up a new scope." { (\{} body) }

fun {map seq f} "Transforms a sequence using f." {if (len seq) {cons (f (eval (head seq))) (map (tail seq) f)}}

(fun 
  {foreach seq f}
  {if (len seq) 
    {do
      (f (head seq))
      (foreach (tail seq) f)}})

fun {filter seq f} "Filters a sequence using f." {
  if (len seq)
    {if (f (eval (head seq)))
      {join (head seq) (filter (tail seq) f)}
      {filter (tail seq) f}}
}

fun {zip a b} {
  if (& (len a) (len b))
    {join (list (join (head a) (head b))) (zip (tail a) (tail b))}
}

(fun 
  {binary_search_impl col l r value error transform}
  {if (> l r)
    error
    {do
      (= {m} (+ l (/ (- r l) 2)))
      (= {mval} (transform (at_eval col m)))
      (if (< value mval)
        {binary_search_impl col l (- m 1) value error transform}
        {if (> value mval)
          {binary_search_impl col (+ m 1) r value error transform}
          {at_eval col m}})}})

(fun {id x} {x})

(fun
  {binary_search col value error}
  {binary_search_impl col 0 (- (len col) 1) value error id})

(fun
  {binary_search_t col value error transform}
  {binary_search_impl col 0 (- (len col) 1) value error transform})

fun {reduce seq f} {
  if (> (len seq) 1)
    {f (eval (head seq)) (reduce (tail seq) f)}
    {eval (head seq)}
}

fun {max a b} {if (>= a b) a b}

fun {at_eval xs x} {eval (at xs x)}

(fun 
  {drop seq n}
  {if n
    {drop (tail seq) (- n 1)}
    {seq}})

(fun
  {take seq n}
  {reverse (drop (reverse seq) (- (len seq) n))})

(fun
  {index_of_impl xs f n}
  {if (len xs)
    {if (f (eval (head xs)))
      n
      {index_of_impl (tail xs) f (+ n 1)}}
    -1})

(fun
  {index_of xs f}
  {index_of_impl xs f 0})

(fun
  {contains xs f}
  {!= -1 (index_of xs f)})

(fun
  {switch value & cases}
  {do
    (if (== 0 (len cases)) {err "Cases must contain at least a default case."})
    (= {idx} (index_of (init cases) (\{x} {== value (eval (head x))})))
    (if (!= idx -1)
      {tail (at_eval cases idx)}
      {eval (last cases)})})

; old split function
(fun
  {partial_compare long short} 
  {if (< (len long) (len short)) 
    0 
    {== (take long (len short)) short}})

(fun
  {spill pair}
  {list
    (join 
      (init (at_eval pair 0))
      (list (join (eval (last (at_eval pair 0))) (head (at_eval pair 1)))))
    (tail (at_eval pair 1))})

(fun
  {split_impl delim pair}
  {do
    (= {rest} (at_eval pair 1))
    (if (len rest)
      {if (partial_compare rest delim)
        {split_impl delim (list (join (at_eval pair 0) {""}) (drop rest (len delim)))}
        {split_impl delim (spill pair)}}
      {at_eval pair 0})})

(fun
  {_split str delim}
  {filter
    (split_impl delim {{""} str})
    len})

